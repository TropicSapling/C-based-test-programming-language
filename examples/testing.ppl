type Nat Zero|(Suc Nat);
type Bool True|False;

func Nat + Nat -> Nat {
	Zero + n => n
	n + Zero => n
	
	Suc Nat n + m => Suc (Nat n + Nat m)
	n + Suc Nat m => Suc (Nat n + Nat m)
}

func _ += _ -> _ {
	(a) += (b) => a = a + b
}

func !Bool -> Bool {
	!True => False
	!False => True
}

func _ == _ -> Bool {
	(a) == (b) => True|False
}

func _ != _ -> _ {
	(a) != (b) => !(a == b)
}

func Bool || Bool -> Bool {
	False || False => False
	False || True  => True
	True  || False => True
	True  || True  => True
}

func Bool && Bool -> Bool {
	False && False => False
	False && True  => False
	True  && False => False
	True  && True  => True
}

func if Bool _ -> _ {
	if True body => body
	if False body => Nothing
}

func if Bool _ else _ -> _ {
	if True body else expr => body
	if False body else expr => expr
}

// ALT.
/*
func Nat + Nat -> Nat {
	Zero + n => n
	n + Zero => n
	
	Suc Nat n + m => Suc (Nat n + Nat m)
	n + Suc Nat m => Suc (Nat n + Nat m)
}

func (Nat n) + (Nat m) -> Nat {
	n = Zero => n
	m = Zero => m
	
	Suc Nat ...
}

func (Bool a) || (Bool b) -> Bool {
	a = True => True
	b = True => True
	_ => False
}

func (Bool a) && (Bool b) -> Bool {
	a = True => {
		b = True => True
		_ => False
	}
	
	_ => False
}

func if (Bool cond) -> body|Nothing {
	cond = True => body
	_ => Nothing
}

func if (Bool cond) (body) else (expr) -> body|expr {
	cond = True => body,
	_ => expr
}
*/
// END ALT.

func rand Nat Nat -> Nat {
	rand start end => start|(Suc Nat start)|...end SYS_RAND start end
}

func println _ -> Void;

let n = Suc Zero; // same as 1
n += rand Zero (Suc Zero); // n = Suc (Zero|(Suc Zero)) which is the same as 1|2

(n = 2|3|...) backwards_println => {
	if True println n; // To test single-line if statements
	
	if 9 + 10 == 21 || 10 + 9 == 21
		println False
	else if 9 + 10 != 21 && !(10 + 9 == 21)
		if True { // To test nested if statements
			println True;
			println True;
		}
	else
		println False;
	
	println n;
};

backwards_println n; // Won't compile, since n must be 2 or more but that can't be guaranteed; n could be either 1 or 2

(typ) [] => Array typ 0 Void;

[(typ item) => {
	let addr = malloc (item size);
    @addr = item;
    Array typ 1 addr
};

Array (typ (len = 1|2|...) addr), (typ item) => {
	let addr = realloc addr (len + 1) * (typ size);
    @(addr + len * (typ size)) = item;
    Array typ (len + 1) addr
};

] => Void;

Array (arr) + (item) => arr, item;
Array (_ len _) length => len;
Array (typ) 1|2|... (addr)[Nat (i)] => @(addr + (typ size) * i);

let numbers = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9];

println numbers[4]; // 4

if rand 0 1 == 1
	numbers += 10;

// numbers = Array Nat 10|11 <addr>

println numbers length; // will print either 10 or 11