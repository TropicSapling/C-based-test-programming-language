// --------------------------------------------------
// |                  THE PRELUDE                   |
// --------------------------------------------------

// TODO: Put the basic things that are needed for the prelude but shouldn't be visible from the
//       outside inside a category 'Foundation'. This can be done by writing the category stuff
//       by hand using anonymous functions, or by generating these anonymous functions.
// OR:   Alternatively, put everything inside 'Prelude' category and then expose Prelude.

// TODO: Fix '@(precedence below ;)' for all functions using 'scope' (including all forms of 'let')
(impure $(let basic        $var = $val;) => scope) (       ($var as frozen code) $val => ($`var` => scope) val)
(impure $(let basic impure $var = $val;) => scope) (impure ($var as frozen code) $val => ($`var` => scope) val)

// TODO: 'let [($a as ...), ($b as ...), ...] = <value>;' function which allows both multiple
//       definitions at once and destructuring of the value.

// Normal 'frozen' keyword only freezes until 'expr' gets used again.
// Use '{expr}' to permafrost 'expr'.
let basic {($expr as frozen)} _ = closed $expr _ => expr;
// Defrost with 'defrost {expr}'.
let basic defrost ($pfexpr as {_}) = $pfexpr => pfexpr _;

// We could've just used 'frozen' here. However, using permafrost forces the user to explicitly
// write '{}', thereby making them aware of the code not being evaluated until later.
// It's convention to make this explicit as long as it doesn't negatively affect user experience.
let basic               basic func ($pattern as frozen code) ($body as {_}); = $pattern $body => frozenraw (let basic        $`pattern` = ALL_ARGS_PLACEHOLDERS pattern => defrost body;);
let basic impure impure basic func ($pattern as frozen code) ($body as {_}); = $pattern $body => frozenraw (let basic impure $`pattern` = ALL_ARGS_PLACEHOLDERS pattern => defrost body;);

basic func declare ($var as frozen code) {
	decl $`var` in scope
};

basic func Typed $expr $type {expr};

List #$first (List _ (List #$want (List _ (List #$last)))) // WIP

basic func __EVAL__ $f {
	let () = __ARGS__; // WIP
};

// TODO: make it work for all functions
basic func __EVAL__ ($f as frozen __ARGS__ [#$first, ..., #(Typed $expr $type), ..., #$last]) { // WIP
	Typed (f expr) type
};

// Pronounced as: "$expr [should] be[come] type"
basic func (Typed #$expr _): $type {expr: type}; // allows for stuff like '(n: 0..): any Int' changing the type of 'n'
basic func ($expr as type ): $type {Typed expr type};
basic func ($expr as {_}  ): $type {(_ => Typed expr type) (defrost expr: type)}; // allows for stuff like '{123}: any Int'

basic func ($expr as type) matches $type {True};
basic func ($expr as {_} ) matches $type {defrost expr matches type};
basic func _               matches $type {False};

basic func (Typed #($var as frozen code) #$type) = ($val as type) {
	ASSIGN var (Typed val type)
};