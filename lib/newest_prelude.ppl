// --------------------------------------------------
// |                  THE PRELUDE                   |
// --------------------------------------------------

// TODO: Put the basic things that are needed for the prelude but shouldn't be visible from the
//       outside inside a category 'Foundation'. This can be done by writing the category stuff
//       by hand using anonymous functions, or by generating these anonymous functions.
// OR:   Alternatively, put everything inside 'Prelude' category and then expose Prelude.

// TODO: Fix '@(precedence below ;)' for all functions using 'scope' (including all forms of 'let')
(impure $(let basic        $var = $val;) => scope) (       ($var as permafrosted) $val => ($`var` => scope) val)
(impure $(let basic impure $var = $val;) => scope) (impure ($var as permafrosted) $val => ($`var` => scope) val)

// TODO: 'let [$a as ..., $b as ..., ...] = <value>;' function which allows both multiple
//       definitions at once and destructuring of the value.

// TODO: Put below info in README:
// - 'permafrosted' is like 'frozen' except the thing stays frozen even after evaluation
//   - is now built-in
//   - evaluate fully using 'defrost'
// - '{}' no longer does anything
// - `` forces evaluation for both 'frozen' and 'permafrosted'
// - 'raw' is now its own thing
//   - can still be used together with 'frozen' and 'permafrosted'

// Useless, but looks nice sometimes.
// Convention to use this whenever $expr spans multiple lines.
// Also use this for the classics 'func', 'if', etc.
let basic {$expr} = $expr => expr;

let basic         basic func ($pattern as permafrosted) ($body as frozen);  = $pattern $body => frozen raw (let basic        `pattern` = ALL_ARGS_PLACEHOLDERS pattern => body;);
let basic (impure basic func ($pattern as permafrosted) ($body as frozen);) = $pattern $body => frozen raw (let basic impure `pattern` = ALL_ARGS_PLACEHOLDERS pattern => body;);

basic func Typed $expr $type _ {};
// If all pattern matching fails, throw away type restriction
basic func __CATCH__ (Typed #$expr _) {expr};

// Pronounced as: "$expr [should] be[come] type"
basic func ($expr as type ): $type {Typed expr type};
basic func (Typed #$expr _): $type {expr: type}; // allows for stuff like '(n: 0..): any Int' changing the type of 'n'

// TODO: 'CONSTRUCTOR_FOR 123' = ???
basic func type of $obj {(CONSTRUCTOR_FOR obj) (ALL_ARGS_BUT_ONE (CONSTRUCTOR_FOR obj))};

// Marker for unchecked input
// File reading, user input, etc. should use this
// Always ensure 'raw' input is ~UncheckedInput
// TODO: Make '__CATCH__' for this or not?
basic func UncheckedInput _ {};

// Pronounced as: "let $var be $type and equal $val"
// let impure $var = $val also works (thanks to 'raw')
basic func let ($var as permafrosted raw ~UncheckedInput): $type = $val {
	frozen raw (let basic `var` = val: type;)
};

basic func let ($var as permafrosted): auto = $val {
	frozen raw (let `var`: type of val = val;)
};

basic func let ($var as permafrosted) = $val {
	frozen raw (let `var`: val = val;)
};

basic func List $item ($tail as List _ _) _ {};

// TODO: List '[]' syntax, list access

// This sets the default list to 'List' and returns 'scope'
SET_DEFAULT_LIST List

// Does not accept unchecked input for security reasons
basic func rec basic func ($pattern as permafrosted raw ~UncheckedInput) ($body as frozen); {
	frozen raw {
		let `pattern` = {
			basic func $f `pattern` {
				let `pattern` = f f;
				body
			};
			
			($f pattern) ($f pattern) // becomes '($f fib $n) ($f fib $n)' => '(($f fib $n) fib $n)' if pattern = 'fib $n'
		};
	}
};

basic func impure rec basic func ($pattern as permafrosted raw ~UncheckedInput) ($body as frozen); {
	frozen raw {
		let impure `pattern` = {
			impure basic func $f `pattern` {
				let `pattern` = f f;
				body
			};
			
			($f pattern) ($f pattern)
		};
	}
};

// Complete *total* functions: allows easy attributes, recursion & types
// - a total function must:
//		- have no infinite loops
//		- cause no side-effects
//		- use no outside/free patterns
// Note: adding 'impure' before '[partial] func' works since 'impure rec func' exists
basic func ##($attrs as permafrosted List _ _) func ($pattern as permafrosted) ($typed_body as frozen); {
	frozen raw {
		// This built-in tells compiler 'pattern' has attributes 'attrs'
		// and returns 'pattern' as permafrosted. The attributes must
		// be given using the default list.
		rec basic func `SET_ATTRIBUTES attrs pattern` {typed_body: ~Undefined};
	}
};

// Complete *partial* functions (I know that sounds contradicting but it's not actually so yeah xD)
basic func ##($attrs as permafrosted List _ _) partial func ($pattern as permafrosted) ($typed_body as frozen); {
	frozen raw {
		rec basic func `SET_ATTRIBUTES attrs pattern` {typed_body};
	}
};

basic func         func ($pattern as permafrosted) ($typed_body as frozen); {[]         func `pattern` {typed_body};};
basic func partial func ($pattern as permafrosted) ($typed_body as frozen); {[] partial func `pattern` {typed_body};};

// The legendary SEMICOLON
##[precedence below _]
func $expr; {
	scope
};

func declare ($var as permafrosted) {
	decl $`var` in scope
};

// 'REF' acts similarly to 'permafrosted' when it comes to evaluation
impure func ($var as REF (Typed _ #$type)) = ($val as type) {
	ASSIGN var (Typed val type)
};

func ref to $val allowing $sub {
	frozen raw (REF (Typed val #$super) where sub matches super)
};

func ref to $val {
	ref to val allowing val
};

// TODO: Booleans

func ($expr as type) matches $type {True};
func _               matches $type {False};

// TODO: Generalise into 'apply $f to itself $n times'
// TODO: Move out of prelude into std lib
func apply $f to itself {f f};