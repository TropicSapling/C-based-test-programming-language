// --------------------------------------------------
// |                  THE PRELUDE                   |
// --------------------------------------------------

// TODO: Put the basic things that are needed for the prelude but shouldn't be visible from the
//       outside inside a category 'Foundation'. This can be done by writing the category stuff
//       by hand using anonymous functions, or by generating these anonymous functions.
// OR:   Alternatively, put everything inside 'Prelude' category and then expose Prelude.

// TODO: Fix '@(precedence below ;)' for all functions using 'scope' (including all forms of 'let')
(impure $(let basic        $var = $val;) => scope) (       ($var as permafrosted) $val => ($`var` => scope) val)
(impure $(let basic impure $var = $val;) => scope) (impure ($var as permafrosted) $val => ($`var` => scope) val)

// TODO: 'let [$a as ..., $b as ..., ...] = <value>;' function which allows both multiple
//       definitions at once and destructuring of the value.

// TODO: Put below info in README:
// - 'permafrosted' is like 'frozen' except the thing stays frozen even after evaluation
//   - is now built-in
//   - evaluate fully using 'defrost'
// - '{}' no longer does anything
// - `` forces evaluation for both 'frozen' and 'permafrosted'
// - 'raw' is now a subtype of 'frozen' and 'permafrosted'
//   - maybe even its own thing?

// Useless, but looks nice when writing definitions.
let basic {$expr} = $expr => expr;

let basic         basic func ($pattern as permafrosted) ($body as frozen);  = $pattern $body => frozen raw (let basic        $`pattern` = ALL_ARGS_PLACEHOLDERS pattern => body;);
let basic (impure basic func ($pattern as permafrosted) ($body as frozen);) = $pattern $body => frozen raw (let basic impure $`pattern` = ALL_ARGS_PLACEHOLDERS pattern => body;);

basic func declare ($var as permafrosted) {
	decl $`var` in scope
};

basic func Typed $expr $type _ {};
// If all pattern matching fails, throw away type restriction
basic func __CATCH__ (Typed #$expr _) {expr};

// Pronounced as: "$expr [should] be[come] type"
basic func ($expr as type ): $type {Typed expr type};
basic func (Typed #$expr _): $type {expr: type}; // allows for stuff like '(n: 0..): any Int' changing the type of 'n'

basic func ($expr as type) matches $type {True};
basic func _               matches $type {False};

// 'REF' acts similarly to 'permafrosted' when it comes to evaluation
impure basic func ($var as REF (Typed _ #$type)) = ($val as type) {
	ASSIGN var (Typed val type)
};

func ref to $val allowing $sub {
	frozenraw (REF (Typed val #$super) where sub matches super)
};

func ref to $val {
	ref to val allowing val
};