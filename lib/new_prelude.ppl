// Syntax sugar
$a                 <=> ($a as _) // 'a' can be called like 'a arg1 arg2 ...'
$(f $a $b ...)     <=> ($(f $a $b ...) as #0 #1 ...)
(x)                <=> (_ as x) // where 'x' is not '$a' ('$a b' is allowed and will become '_ as $a b')

// Requirements for *complete* functions (*basic* functions don't allow these easily)
- Attributes
- Recursion
- Types

////////////////////////////////////////////////////////////////

($(let basic $var = $val;) => scope) (($var as frozen) $val => (var => scope) val)

// Normal 'frozen' keyword only freezes until 'expr' gets used again.
// Use '{expr}' to permafrost 'expr'. Defrost with 'defrost {expr}'.
let basic $({($expr as frozen)} _)           = $expr   _ => expr;
let basic $(permafrosted ($input as frozen)) = $input    => frozen ($(input _));
let basic $(defrost (permafrosted $pfexpr))  = $pfexpr   => pfexpr _;

// We could've just used 'frozen' here. However, using permafrost
// forces the user to explicitly write '{}', thereby making them
// aware of the code not being evaluated until later.
// It's convention to make this explicit as long as it
// doesn't negatively affect user experience.
let basic $(basic func ($pattern as frozen) $(permafrosted body);) = $pattern $body => frozen (let basic $pattern = ALL_ARGS pattern => defrost body;);

basic func Nothing $f $x {scope};

basic func remaining args of $f {
	ALL_ARGS f length - APPLIED_ARGS f length
};

// Boxes
basic func category of ($wrapper (ALL_ARGS wrapper)) {wrapper};
basic func unbox $b {APPLIED_ARGS b};

// Bool True|False
basic func Bool True  $x _  {x};
basic func Bool False _  $y {y};

let basic $True  = Bool True;
let basic $False = Bool False;

basic func (True)  && ($b as  Bool _) {b};
basic func (False) && (frozen Bool _) {False};

basic func (True)  || (frozen Bool _) {False};
basic func (False) || ($b as  Bool _) {b};

basic func !(True)  {False};
basic func !(False) {True};

basic func $a == $a {True};
basic func _  == _  {False};
basic func $a != $b {!(a == b)};

// if _ _ else
// ex: 'if x == 123 {456} else {789}'
basic func if (True)  (permafrosted $body)                           {defrost body};
basic func if (False) (permafrosted $body)                           {scope};
basic func if (True)  (permafrosted $body) else (permafrosted $expr) {defrost body};
basic func if (False) (permafrosted $body) else (permafrosted $expr) {defrost expr};

// if _ then _ else _
// ex: 'if x == 123 then 456 else 789'
basic func if $cond then ($body as frozen)                        {if cond {body}};
basic func if $cond then ($body as frozen) else ($expr as frozen) {if cond {body} else {expr}};

// Type checking
basic func any $b {b (ALL_ARGS b)};

basic func if fulfilling (True)                   (permafrosted $body) {body};
basic func if fulfilling ($cond as frozen Bool _) (permafrosted $body) {
	// continue to next function def if there is one, else panic
	continue from caller or alt prerun panic (format_err (format "Failed to fulfill condition '{}'" [stringify {cond}]))
};

basic func if fulfilling (True)  (permafrosted $body) else report _             {body};
basic func if fulfilling (False) (permafrosted $body) else report (String $msg) {
	continue from caller or alt prerun panic (format_err (String msg))
};

// TODO: Generalise into 'apply $f to itself $n times'
basic func apply $f to itself {f f};

basic func $f using $closure => if fulfilling remaining args of closure == 1 (
	f ((closure _) f)
);

basic func @($attr as frozen) $(id as frozen) {
	ATTRIBUTE attr id // this built-in tells compiler 'id' has attribute 'attr' and returns 'id'
}; // use '##' instead if you decide to use '@' for pointers

basic func attr func ... // TODO

basic func rec func $pattern ($body _); {
	frozen (
		let basic pattern = (
			basic func $f pattern {
				let basic $pattern = (f) f;
				body _
			};
			
			($f pattern) ($f pattern) // becomes '($f fib $n) fib $n' if pattern = 'fib $n'
		);
	)
};

// The legendary SEMICOLON
@(precedence below _) func $expr; {
	scope
}: auto;

// TODO: Fix so that stuff below works with new syntax

memo _ => (
	let basic $cache = [];
	
	$f $next $x => if cache.x exists (
		cache.x
	) else f (next) x
);

fibY $next $n => if n < 2 (
	1
) else next (next) (n - 2) + next (next) (n - 1);

// Better version?
basic func fibR $fibR $n {
	if n < 2 {
		1
	} else {
		fibR (fibR) (n - 2) + fibR (fibR) (n - 1)
	}
};

fibR (fibR) 123

// test impl
basic func rec func $pattern ($body _); {
	frozen (
		let basic pattern = (
			basic func $f pattern {
				let basic $pattern = (f) f;
				body _
			};
			
			($f pattern) ($f pattern) // becomes '($f fib $n) fib $n' if pattern = 'fib $n'
		);
	)
};

rec func fib $n {
	if n < 2 {
		1
	} else {
		fib (n - 2) + fib (n - 1)
	}
};

=>

let basic fib $n = (
	basic func $f fib $n {
		let basic $(fib $n) = (f) f;
		if n < 2 {
			1
		} else {
			fib (n - 2) + fib (n - 1)
		}
	};

	($f fib $n) fib $n
);

fib 5

fibMemo $n => (fibY using memo) n;

-------------------------------------------------

// Parsing instructions
(($(add (4) to ($(a) as 7)) as #a #0) => add 4 to 7) ($x _ => x + 4)

1. Choose a $(...) and move to its outside
2. If inside another $(...), move to its outside, and then keep leaving scopes until you find 'as'
   If not, keep leaving scopes until you find '=>'
3. Your variable is defined after this 'as' or '=>'

---------------------

Let f $x, $a f $b be patterns/functions

Then:
      f <=>      f $x
$a f <=> $a f $b

let f = $x => ...;
<=>
let f $x = $x => ...;

This is because there is no pattern matching before ‘as’. So doing ‘$x’ there serves no other purpose than naming the pattern / which order args come in.

Both patterns and anonymous functions can be passed around as values.

‘$x => ...` is almost equivalent to ‘$x’.

All inputs to functions are parenthesised. They are also evaluated unless frozen.

---------------------

Number literals can be linked to types for a certain scope. This allows changing the link for different scope, a.k.a. changing the representation (between for example machine and natural numbers).

// default representation, change part
// after ‘=‘ to change representation
let __NUMBERS__ = any Nat;
let __STRINGS__ = any String;