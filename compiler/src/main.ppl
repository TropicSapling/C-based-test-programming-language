#include <stdio.h>;
#include <stdlib.h>;
#include <errno.h>;
#include <string.h>;
#include <sys/stat.h>;

#include "def.h";

const char pointer const unique specials -> ";,[]{}()?><=+-*/%!&|^~@\\.:";

size_t keywords_size = sizeof(char pointer) * 32;
size_t pointers_size = sizeof(char pointer) * 32;
size_t key = 0;
size_t pkey = 0;
size_t pos = 0;

void printErrInfo(struct ErrInfo Error) {
	puts("----------------------------------------------------------------");
	
	if(Error.data == NULL && Error.data2 == NULL) {
		printf(WHITE "%s:%zu:" RESET " %s\n", Error.filename, Error.lineno, Error.msg);
	} else {
		printf(WHITE "%s:%zu:%zu:" RESET " %s\n", Error.filename, Error.lineno, Error.linecol, Error.msg);
		printf("	...%s %s %s " RED "__item" RESET " %s %s %s...\n", Error.data2[Error.i - 3], Error.data2[Error.i - 2], Error.data2[Error.i - 1], Error.data2[Error.i + 1], Error.data2[Error.i + 2], Error.data2[Error.i + 3]);
	}
	
	puts("----------------------------------------------------------------");
}

void printWarning(struct ErrInfo Error) {
	char pointer msg = malloc(strlen(Error.msg) + 7);
	strcpy(msg, YELLOW "Warning:" RESET);
	strcat(msg, Error.msg);
	
	printErrInfo((struct ErrInfo) {msg, Error.filename, Error.lineno, Error.linecol, Error.data, Error.data2, Error.i});
	
	free(msg);
}

void printErr(struct ErrInfo Error) {
	char pointer msg = malloc(strlen(Error.msg) + 7);
	strcpy(msg, RED "Error:" RESET);
	strcat(msg, Error.msg);
	
	printErrInfo((struct ErrInfo) {msg, Error.filename, Error.lineno, Error.linecol, Error.data, Error.data2, Error.i});
	
	free(msg);
}

int main(int argc, char pointer argv[]) {
	
	//////////////// PREPARE FOR LEXING ////////////////
	
	if(argc < 2 || argc > 3) {
		puts("Invalid usage. Please specify an input file as the first argument and an output file as the second argument.");
		return 1;
	}
	
	FILE pointer input = fopen(argv[1], "r"); // Will be "r+" if automatic compiled GC gets added in the future and/or if needed to fix 'read-dir' bug
	
	if(input == NULL) {
		perror("ERROR");
		fprintf(stderr, "ID: %d\n", errno);
		return 1;
	}
	
	///////////////// PREPROCESS INPUT /////////////////
	
	char defs[128][2][128];
	size_t defID = 0;
	
	size_t processed_input_size = 256;
	char pointer processed_input = malloc(processed_input_size);
	preprocess(->input, ->processed_input, processed_input_size, argv, NULL, NULL, NULL, defs, ->defID);
	
	fclose(input);
	
	puts("[DEBUG] Read and preprocessed file.");
	
	/////////////////// START LEXING ///////////////////
	
	char pointer*2 keywords = malloc(keywords_size);
	char pointer*2 pointers = malloc(pointers_size);
	
	lex_parse(processed_input, ->keywords, ->pointers);
	
	puts("[DEBUG] Lex-parsed input.");
	
	/////////////////// START PARSING //////////////////
	
	char pointer parsed_output = parse(keywords, argv[1]);
	
	free(processed_input);
	
	puts("[DEBUG] Parsed input.");
	
	//////////////// PREPARE FOR OUTPUT ////////////////
	
	FILE pointer output;
	
	if(argc < 3) {
		size_t file_length = strlen(argv[1]);
		char filename[file_length];
		strcpy(filename, argv[1]);
		
		size_t c = file_length - 1;
		while(filename[c] != '.') {
			c--;
		}
		
		memset(->filename[c + 1], 'c', 1);
		memset(->filename[c + 2], '\0', 1);
		
		while(filename[c] != '/' && c > 0) {
			c--;
		}
		
		char finalname[strlen(filename) + 4];
		char success;
		
		if(c == 0) {
			success = mkdir("bin", 0777);
			
			strcpy(finalname, "bin/");
			strcat(finalname, filename);
		} else {
			strncpy(finalname, filename, c + 1);
			finalname[c + 1] = '\0';
			strcat(finalname, "bin/");
			success = mkdir(finalname, 0777);
			strcat(finalname, ->filename[c + 1]);
		}
		
		if(success != 0 && errno != 17) {
			perror("ERROR");
			fprintf(stderr, "ID: %d\n", errno);
			
			return 1;
		}
		
		output = fopen(finalname, "w");
	} else {
		output = fopen(argv[2], "w");
	}
	
	/////////////////// PRINT OUTPUT ///////////////////
	
	for(size_t i = 0; i < pos; i++) {
		fprintf(output, "%c", parsed_output[i]);
		
		printf("[DEBUG] Printing output... %.2Lf%%\r", (((long double) i + 1) / key) * 100);
	}
	
	fclose(output);
	puts("[DEBUG] Printing output... 100.00%");
	
	/////////////////// FREE MEMORY ////////////////////
	
	free(parsed_output);
	
	for(size_t i = 0; i < pkey; i++) {
		free(pointers[i]);
	}
	
	free(keywords);
	free(pointers);
	
	return 0;
}